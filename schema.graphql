### This file was generated by Nexus Schema
### Do not make changes to this file directly

input AcceptInviteInput {
  code: String!
  email: String!
  password: String!
}

type AdminUser {
  ambassador: Ambassador
  avatarUrl: String
  business: Business
  campaign: String
  createdAt: DateTime!
  email: String!
  firstName: String
  id: String!
  isAdmin: Boolean!
  isDisabled: Boolean!
  isEmailValidated: Boolean!
  lastLogin: DateTime
  lastName: String
  password: String!
  requestedCategories: [String]
  role: Role!
  shouldResetPassword: Boolean!
  type: UserType
  updatedAt: DateTime!
  validateEmailToken: String
}

type Ambassador {
  businesses: [Business]
  createdAt: DateTime
  creditAllowance: Int
  handle: String!
  id: String!
  owner: User
  ownerId: String!
  refCode: String!
  updatedAt: DateTime
}

input AmbassadorUpdateInput {
  creditAllowance: Int
  handle: String
}

input AmbassadorUpdateManyMutationInput {
  creditAllowance: IntUpdateInput
}

input AmbassadorWhereInput {
  AND: [AmbassadorWhereInput]
  NOT: [AmbassadorWhereInput]
  OR: [AmbassadorWhereInput]
  handle: StringFilter
}

input AttachCategoriesInput {
  requestedCategories: [String]!
}

type AuthPayload {
  authToken: String!
  user: User!
}

type BatchCount {
  count: Int!
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolUpdateInput {
  set: Boolean
}

type BugFormToSlack {
  action: String!
  businessEmail: String!
  businessName: String!
  businessPhone: String!
  contact: String!
  expectation: String!
  frequency: String!
  priority: String!
  user: String!
}

input BugFormToSlackInput {
  action: String!
  businessEmail: String!
  businessName: String!
  businessPhone: String!
  contact: String!
  expectation: String!
  frequency: String!
  priority: String!
  user: String!
}

type Business {
  address: String
  ambassador: Ambassador
  ambassadorId: String
  approved: Boolean
  coverUrl: String
  createdAt: DateTime
  description: String
  email: String
  emailNotifications: Boolean
  externalLinks: [String]
  handle: String!
  id: String!
  isDisabled: Boolean
  isEmailValidated: Boolean
  isSmsValidated: Boolean
  kmsTaxId: String
  listings: [Listing]
  logoUrl: String
  markets: [Market!]!
  name: String!
  notificationEmail: String
  notificationPhone: String
  owner: User
  ownerId: String!
  phoneNumber: String
  settings: BusinessSettings
  smsNotifications: Boolean
  tagline: String
  transactions: [Transaction]
  updatedAt: DateTime
  wallet: Wallet
}

input BusinessListRelationFilter {
  every: BusinessWhereInput
  none: BusinessWhereInput
  some: BusinessWhereInput
}

input BusinessOrderByInput {
  handle: OrderBy
}

type BusinessSettings {
  business: Business
  businessId: String
  createdAt: DateTime!
  emailChat: Boolean
  emailMarketing: Boolean
  emailNotifications: Boolean
  emailProductUpdates: Boolean
  id: String!
  isEmailValidated: Boolean
  isSmsValidated: Boolean
  languages: [Languages]
  notificationEmail: String
  notificationPhone: String
  oneTimePassword: String
  showSmsOptIn: Boolean
  smsChat: Boolean
  smsNotifications: Boolean
  smsTransaction: Boolean
  timezone: String
  udpatedAt: DateTime!
}

input BusinessSettingsWhereInput {
  businessId: StringFilter
  createdAt: DateTime
  emailChat: Boolean
  emailMarketing: Boolean
  emailNotifications: Boolean
  emailProductUpdates: Boolean
  id: String
  isEmailValidated: Boolean
  isSmsValidated: Boolean
  notificationEmail: StringFilter
  notificationPhone: StringFilter
  oneTimePassword: StringFilter
  showSmsOptIn: Boolean
  smsChat: Boolean
  smsNotifications: Boolean
  smsTransaction: Boolean
  timezone: StringFilter
  udpatedAt: DateTime
}

input BusinessUpdateInput {
  address: String
  ambassadorCode: String
  ambassadorId: String
  coverUrl: String
  description: String
  email: String
  emailNotifications: Boolean
  externalLinks: [String]
  handle: String
  isEmailValidated: Boolean
  isSmsValidated: Boolean
  kmsTaxId: String
  logoUrl: String
  marketName: String
  name: String
  notificationEmail: String
  notificationPhone: String
  phoneNumber: String
  showSmsOptIn: Boolean
  smsNotifications: Boolean
  tagline: String
}

input BusinessUpdateManyMutationInput {
  creditLimit: IntUpdateInput
  isDisabled: BoolUpdateInput
}

input BusinessWhereInput {
  AND: [BusinessWhereInput]
  NOT: [BusinessWhereInput]
  OR: [BusinessWhereInput]
  address: StringFilter
  ambassadorId: StringFilter
  approved: BoolFilter
  coverUrl: StringFilter
  createdAt: DateTimeFilter
  description: StringFilter
  email: StringFilter
  handle: StringFilter
  id: StringFilter
  isDisabled: BoolFilter
  markets: [MarketWhereInput!]
  name: StringFilter
  ownerId: StringFilter
  phoneNumber: StringFilter
  settings: BusinessSettingsWhereInput
  showSmsOptIn: BoolFilter
  tagline: StringFilter
  updatedAt: DateTimeFilter
  wallet: WalletWhereInput
}

type Catalog {
  coverImage: String!
  coverTitle: String!
  createdAt: DateTime!
  footerImage: String!
  footerTitle: String!
  id: String!
  lists: [MarketplaceList!]!
  market: Market
  updatedAt: DateTime!
}

input CatalogWhereInput {
  AND: [CatalogWhereInput]
  NOT: [CatalogWhereInput]
  OR: [CatalogWhereInput]
  coverTitle: StringFilter
  id: String
  market: MarketWhereInput
}

input CategoryUpdateInput {
  icon: String
  name: String
}

input CategoryWhereInput {
  createdAt: DateTimeFilter
  icon: StringFilter
  id: StringFilter
  name: StringFilter
  parentId: StringFilter
  updatedAt: DateTimeFilter
}

type Channel {
  id: String
}

type CipherPayload {
  data: String
}

input CreateAmbassadorInput {
  creditAllowance: Int
  handle: String!
  ownerId: String!
}

input CreateBusinessInput {
  address: String
  ambassadorCode: String
  ambassadorId: String
  coverUrl: String
  description: String
  email: String
  emailNotifications: Boolean
  externalLinks: [String]
  handle: String!
  isEmailValidated: Boolean
  isSmsValidated: Boolean
  kmsTaxId: String!
  logoUrl: String
  marketName: String
  name: String!
  notificationEmail: String
  notificationPhone: String
  ownerId: String!
  phoneNumber: String
  smsNotifications: Boolean
  tagline: String
}

input CreateBusinessInviteInput {
  address: String
  ambassadorCode: String
  ambassadorId: String
  coverUrl: String
  description: String
  email: String
  emailNotifications: Boolean
  externalLinks: [String]
  handle: String!
  isEmailValidated: Boolean
  isSmsValidated: Boolean
  kmsTaxId: String
  logoUrl: String
  name: String!
  notificationEmail: String
  notificationPhone: String
  phoneNumber: String
  smsNotifications: Boolean
  tagline: String
}

input CreateBusinessWithListingsInput {
  business: CreateBusinessInput!
  listings: [CreateListingWithoutBusinessInput]
}

input CreateCategoryInput {
  icon: String
  name: String
}

input CreateListingInput {
  address: String
  availability: String
  businessId: String!
  calendarLink: String
  categoryId: String
  cost: Decimal
  deliveryNotes: String
  description: String
  imageUrl: String
  isDeliverable: Boolean
  isLocal: Boolean
  isVirtual: Boolean
  maxPrice: Decimal
  minPrice: Decimal
  quantity: Int
  tags: [String]
  title: String
  type: ListingType
  videoUrl: String
}

input CreateListingWithoutBusinessInput {
  address: String
  availability: String
  calendarLink: String
  categoryId: String
  cost: Decimal
  deliveryNotes: String
  description: String
  imageUrl: String
  isDeliverable: Boolean
  isLocal: Boolean
  isVirtual: Boolean
  maxPrice: Decimal
  minPrice: Decimal
  quantity: Int
  tags: [String]
  title: String
  type: ListingType
  videoUrl: String
}

input CreateOrderInput {
  deliveryAddress: String!
  fulfillmentMethod: String!
  listingId: String!
  note: String!
  quantity: Int!
  txData: String!
  txSignature: String!
}

input CreateRequestFormToSlackInput {
  businessEmail: String!
  businessName: String!
  businessPhone: String!
  companyLead: String
  contactMe: String!
  mainRequest: String!
  requestDetails: String
  user: String!
}

input CreateTransactionInput {
  amount: Decimal!
  note: String!
  recipientBusinessId: String!
  senderBusinessId: String!
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  notIn: [DateTime]
}

input DateTimeUpdateInput {
  set: DateTime
}

"""
Decimal custom scalar type
"""
scalar Decimal

input DecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role]
  not: NestedEnumRoleFilter
  notIn: [Role]
}

input EnumStateFieldUpdateOperationsInput {
  set: OrderStatus
}

type FeedbackFormToSlack {
  businessEmail: String!
  businessName: String!
  businessPhone: String!
  details: String
  feedback: String!
  priority: String!
  user: String!
}

input FeedbackFormToSlackInput {
  businessEmail: String!
  businessName: String!
  businessPhone: String!
  details: String
  feedback: String!
  priority: String!
  user: String!
}

enum FulfillmentMethod {
  DELIVERY
  LOCAL
  VIRTUAL
}

type HandleNode {
  handle: String
  isUnique: Boolean
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input IntUpdateInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input InviteAmbassadorInput {
  creditAllowance: Int
  email: String!
  firstName: String
  handle: String!
  lastName: String
}

input InviteBusinessInput {
  business: CreateBusinessInviteInput
  campaign: String
  email: String!
  firstName: String
  lastName: String
  type: String
}

enum Languages {
  AFRIKAANS
  ALGERIAN
  AMHARIC
  ARABIC
  ARAMAIC
  ARMENIAN
  BENGALI
  BERBER
  BHOJPURI
  BOSNIAN
  BRAZILIAN
  BULGARIAN
  BURMESE
  CANTONESE
  CATALAN
  CORSICA
  CREOLE
  CROATIAN
  CYPRIOT
  CZECH
  DANISH
  DUTCH
  EGYPTIAN
  ENGLISH
  ESPERANTO
  ESTONIAN
  FILIPINO
  FINN
  FINNISH
  FLEMISH
  FRENCH
  GEORGIAN
  GERMAN
  GREEK
  GUIJARATI
  GYPSY
  HAWAIIAN
  HEBREW
  HINDI
  HUASA
  HUNGARIAN
  ICELANDIC
  INDONESIAN
  INUIT
  IRISH
  ITALIAN
  JAPANESE
  JAVANESE
  KANNADA
  KOREAN
  LATIN
  LITHUANIAN
  MALAY
  MALAYALAM
  MANDARIN
  NEPALESE
  NORWEGIAN
  PANJABI
  PERSIAN
  POLISH
  PORTUGUESE
  ROMANI
  ROMANIAN
  RUSSIAN
  SANSKRIT
  SCOTTISH
  SERBIAN
  SIGNLANGUAGE
  SLOVAK
  SLOVENE
  SPANISH
  SWAHILI
  SWEDISH
  TAGALOG
  TAHITIAN
  TAMIL
  TELUGU
  THAI
  TIBETAN
  TURKISH
  UKRAINIAN
  VIETNAMESE
  WELSH
  WU
  YORUBA
}

type Listing {
  address: String
  availability: String
  business: Business
  businessId: String!
  calendarLink: String
  category: ListingCategory
  categoryId: String
  cost: Decimal
  createdAt: DateTime!
  deliveryNotes: String
  description: String
  id: ID!
  imageUrl: String
  isDeliverable: Boolean
  isDisabled: Boolean
  isFeatured: Boolean
  isLocal: Boolean
  isVirtual: Boolean
  maxPrice: Decimal
  minPrice: Decimal
  quantity: Int
  tags: [String]
  title: String
  type: ListingType
  updatedAt: DateTime!
  videoUrl: String
}

type ListingCategory {
  createdAt: DateTime!
  icon: String
  id: ID!
  name: String!
  parent: ListingCategory
  parentId: String
  subcategories: [ListingCategory]
}

enum ListingType {
  EXPERIENCE
  PRODUCT
  SERVICE
}

input ListingWhereInput {
  AND: [ListingWhereInput]
  NOT: [ListingWhereInput]
  OR: [ListingWhereInput]
  address: StringFilter
  availability: StringFilter
  businessId: String
  calendarLink: StringFilter
  category: CategoryWhereInput
  cost: DecimalFilter
  createdAt: DateTimeFilter
  deliveryNotes: StringFilter
  description: StringFilter
  id: StringFilter
  isDeliverable: Boolean
  isDisabled: Boolean
  isFeatured: Boolean
  isLocal: Boolean
  isVirtual: Boolean
  maxPrice: DecimalFilter
  minPrice: DecimalFilter
  quantity: IntFilter
  title: StringFilter
  type: StringFilter
  updatedAt: DateTimeFilter
}

type ManyAmbassador {
  ambassadors: [Ambassador]
  total: Int
}

type ManyBusiness {
  businesses: [Business]
  total: Int
}

type ManyCatalog {
  catalogs: [Catalog]
  total: Int
}

type ManyListing {
  listings: [Listing]
  total: Int
}

type ManyListingCategory {
  categories: [ListingCategory]
  total: Int
}

type ManyMarketplaceList {
  marketplaceLists: [MarketplaceList]
  total: Int
}

type ManyTransaction {
  total: Int!
  transactions: [Transaction]!
}

type Market {
  catalogs: [Catalog!]!
  createdAt: DateTime!
  id: String!
  name: String!
  updatedAt: DateTime!
}

input MarketWhereInput {
  AND: [MarketWhereInput]
  NOT: [MarketWhereInput]
  OR: [MarketWhereInput]
  id: String
  name: StringFilter
}

type MarketplaceList {
  coverImage: String!
  createdAt: DateTime!
  icon: String
  id: String!
  listings: [Listing!]!
  order: Int!
  sublists: [MarketplaceList!]!
  title: String!
  updatedAt: DateTime!
}

type Mutation {
  acceptInvite(data: AcceptInviteInput): AuthPayload!
  assignCredit(id: ID!, limit: String!): Wallet!
  checkEmailVerification(businessId: ID!, code: String!): VerifyPayload!
  checkSmsVerification(businessId: ID!, code: String!, to: String!): VerifyPayload!
  claimWallet(clientAddress: String!, guardianAddress: String!, id: ID!): Wallet!
  createAmbassador(data: CreateAmbassadorInput): Ambassador!
  createAmbassadorInvite(data: InviteAmbassadorInput): Ambassador!
  createBusiness(data: CreateBusinessInput): Business!
  createBusinessInvite(data: InviteBusinessInput): Business!
  createCategory(data: CreateCategoryInput): ListingCategory!
  createListing(data: CreateListingInput): Listing!
  createOrder(data: CreateOrderInput): Order!
  deleteManyCategory(where: CategoryWhereInput!): BatchCount!
  deleteOneCategory(id: ID!): ListingCategory
  disableUser(id: ID!): User
  doubleEncryptHash(encryptedHash: String!): CipherPayload!
  findOrCreateChannel(targetBusinessId: ID!): Channel!
  loginUser(email: String!, password: String!): AuthPayload!
  registerUser(data: UserCreateInput!): AuthPayload!
  requestEmailVerification(businessId: ID!, email: String!): VerifyPayload!
  requestReset(email: String!): Boolean
  requestSmsVerification(to: String!): VerifyPayload!
  resetOTP(email: String!): Boolean
  resetPassword(
    confirmPassword: String!
    email: String!
    password: String!
    validateEmailToken: String!
  ): AuthPayload!
  resetPasswordWithGuardian(
    email: String!
    newClientAddress: String!
    password: String!
    transactionId: String!
  ): AuthPayload!
  retryTransaction(transactionId: ID!, txData: String!, txSignature: String!): Transaction!
  sendAmbassadorInvite(id: ID!): Ambassador!
  sendBugFormToSlack(data: BugFormToSlackInput!): Boolean
  sendBusinessInvite(id: ID!): Business!
  sendFeedbackFormToSlack(data: FeedbackFormToSlackInput!): Boolean
  sendRequestFormToSlack(data: CreateRequestFormToSlackInput!): Boolean
  sendRusd(data: SendRusdInput): Transaction!
  sendWelcomeEmail(email: String!): Boolean
  toggleBusiness(id: ID!): Business!
  toggleListing(id: ID!): Listing
  updateAmbassador(data: AmbassadorUpdateInput!, id: ID!): Ambassador!
  updateBusiness(data: BusinessUpdateInput!, id: ID!): Business!
  updateBusinessSettingsByBusiness(
    businessId: ID!
    data: UpdateBusinessSettingsInput
  ): BusinessSettings!
  updateCatalog(data: UpdateCatalogInput!): Catalog!
  updateListing(data: UpdateListingInput, id: ID!): Listing
  updateManyCategory(data: CategoryUpdateInput!, where: CategoryWhereInput): BatchCount
  updateMarketplaceList(data: UpdateMarketplaceListInput): MarketplaceList!
  updateOrderStatus(data: UpdateOrderStatusInput!, id: ID!): Order!
  updateUser(data: UserUpdateInput, id: ID!): User
  verifyOTP(email: String!, otp: String!): Boolean
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: DateTimeFilter
  notIn: [DateTime]
}

input NestedDecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role]
  notIn: [Role]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

type Order {
  amount: Decimal!
  createdAt: DateTime!
  deliveryAddress: String
  events: OrderEvent
  fulfillmentMethod: FulfillmentMethod
  id: String!
  listing: Listing
  listingId: String!
  note: String!
  quantity: Int!
  status: OrderStatus!
  updatedAt: DateTime!
}

enum OrderBy {
  asc
  desc
}

type OrderEvent {
  createdAt: DateTime!
  fromStatus: OrderStatus!
  id: String!
  note: String
  order: Order!
  orderId: String!
  toStatus: OrderStatus!
}

enum OrderStatus {
  CANCELLED
  CLOSED
  INPROGRESS
  OPEN
}

input OrderStatusFilter {
  equals: OrderStatus
}

input OrderWhereInput {
  AND: [OrderWhereInput]
  NOT: [OrderWhereInput]
  OR: [OrderWhereInput]
  amount: DecimalFilter
  createdAt: DateTimeFilter
  id: StringFilter
  listing: ListingWhereInput
  listingId: StringFilter
  note: StringFilter
  quantity: IntFilter
  status: OrderStatusFilter
  transaction: TransactionWhereInput
  transactionId: StringFilter
}

input OrderWhereUniqueInput {
  id: String
}

type Query {
  allBusinessTransactions(id: ID!, skip: Int, take: Int): [Transaction]
  allOrders(skip: Int, take: Int, where: OrderWhereInput): [Order]
  businessTransactionStats(businessId: ID!): TransactionStatsOutput
  countAllBusiness(where: BusinessWhereInput): Int
  countAllCategory(where: CategoryWhereInput): Int
  countAllListing(where: ListingWhereInput): Int
  countAllOrders(where: OrderWhereInput): Int!
  countAllTransactions(where: TransactionWhereInput): Int
  countAllUsers(where: UserWhereInput): Int
  findAllUsers(skip: Int, take: Int, where: UserWhereInput): [AdminUser!]!
  findByBusiness(id: ID!, limit: Int, page: Int): ManyListing
  findCatalogById(id: ID!): Catalog
  findFirstBusiness(where: BusinessWhereInput!): Business
  findFirstCatalog(where: CatalogWhereInput!): Catalog
  findManyAmbassador(limit: Int, page: Int, where: AmbassadorWhereInput): ManyAmbassador
  findManyBusiness(limit: Int, page: Int, where: BusinessWhereInput): ManyBusiness
  findManyCatalog: ManyCatalog
  findManyCategory(limit: Int, page: Int, where: CategoryWhereInput): ManyListingCategory
  findManyListing(limit: Int, page: Int, where: ListingWhereInput): ManyListing
  findManyTransactions(
    limit: Int
    orderBy: TransactionOrderByInput
    page: Int
    where: TransactionWhereInput
  ): ManyTransaction
  findMarketplaceListById(id: ID!): MarketplaceList
  findOneAmbassadorByHandle(handle: String!): Ambassador
  findOneAmbassadorById(id: ID!): Ambassador
  findOneBusinessByHandle(handle: String!): Business
  findOneBusinessById(id: ID!): Business
  findOneCategory(id: ID!): ListingCategory
  findOneListing(id: ID!): Listing
  findOneOrder(id: ID!): Order
  findTransactionById(id: ID!): Transaction
  findTransactionByTxId(txId: String!): Transaction
  findUserByEmail(email: String!): User
  findUserById(id: ID!): User
  getBusinessStreamToken(businessId: ID!): String
  getOrderTotal(listingId: ID!, quantity: Int!): Decimal!
  isAmbassadorHandleUnique(handle: String!): HandleNode!
  isBusinessHandleUnique(handle: String!): HandleNode!
  isEmailUnique(email: String!): Boolean
  isInviteCodeValid(code: String!): Boolean
  me: User
  searchBusinesses(filters: String, limit: Int, page: Int, query: String!): ManyBusiness!
  searchListings(filters: String, limit: Int, page: Int, query: String!): ManyListing!
  totalTransactionVolume(where: TransactionWhereInput): Decimal
  walletBalance(id: ID!): WalletBalance!
}

type RequestFormToSlack {
  businessEmail: String!
  businessName: String!
  businessPhone: String!
  companyLead: String
  contactMe: String!
  mainRequest: String!
  requestDetails: String
  user: String!
}

enum Role {
  ADMIN
  USER
}

input SendRusdInput {
  amount: Decimal!
  note: String!
  recipientBusinessId: String!
  senderBusinessId: String!
  txData: String!
  txSignature: String!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

type Transaction {
  amount: Decimal!
  createdAt: DateTime
  id: ID!
  note: String
  order: Order
  recipient: Wallet
  recipientId: String!
  sender: Wallet
  senderId: String!
  status: TransactionStatus
  txHash: String
  txId: String
}

input TransactionOrderByInput {
  amount: OrderBy
  createdAt: OrderBy
  status: OrderBy
}

type TransactionStatsOutput {
  count: Int!
  volume: Decimal!
}

enum TransactionStatus {
  CONFIRMED
  FAILED
  PENDING
  QUEUED
}

input TransactionStatusFilter {
  equals: TransactionStatus
}

input TransactionWhereInput {
  AND: [TransactionWhereInput]
  NOT: [TransactionWhereInput]
  OR: [TransactionWhereInput]
  amount: DecimalFilter
  createdAt: DateTimeFilter
  id: StringFilter
  listing: ListingWhereInput
  listingId: StringFilter
  order: OrderWhereInput
  orderId: StringFilter
  recipient: BusinessWhereInput
  recipientId: StringFilter
  sender: WalletWhereInput
  senderId: StringFilter
  status: TransactionStatusFilter
}

input TransactionWhereUniqueInput {
  id: String
}

input UpdateBusinessSettingsInput {
  emailChat: Boolean
  emailMarketing: Boolean
  emailNotifications: Boolean
  emailProductUpdates: Boolean
  isEmailValidated: Boolean
  isSmsValidated: Boolean
  languages: [Languages]
  notificationEmail: String
  notificationPhone: String
  oneTimePassword: String
  showSmsOptIn: Boolean
  smsChat: Boolean
  smsNotifications: Boolean
  smsTransaction: Boolean
  timezone: String
}

input UpdateCatalogInput {
  coverImage: String!
  coverTitle: String!
  footerImage: String!
  footerTitle: String!
  id: ID!
  lists: [UpdateMarketplaceListInput!]!
}

input UpdateListingInput {
  address: String
  availability: String
  calendarLink: String
  categoryId: String
  cost: Decimal
  deliveryNotes: String
  description: String
  imageUrl: String
  isDeliverable: Boolean
  isFeatured: Boolean
  isLocal: Boolean
  isVirtual: Boolean
  maxPrice: Decimal
  minPrice: Decimal
  quantity: Int
  tags: [String]
  title: String
  type: String
  videoUrl: String
}

input UpdateListingsOnMarketplaceListInput {
  business: BusinessUpdateInput
  id: ID!
  order: Int
}

input UpdateMarketplaceListInput {
  coverImage: String!
  icon: String
  id: ID!
  listings: [UpdateListingsOnMarketplaceListInput!]!
  order: Int
  sublists: [UpdateMarketplaceListInput!]!
  title: String!
}

input UpdateOrderStatusInput {
  note: String
  status: OrderStatus!
}

type User {
  ambassador: Ambassador
  avatarUrl: String
  business: Business
  campaign: String
  createdAt: DateTime!
  email: String!
  firstName: String
  id: String!
  isAdmin: Boolean!
  isDisabled: Boolean!
  isEmailValidated: Boolean!
  lastLogin: DateTime
  lastName: String
  password: String!
  requestedCategories: [String]
  role: Role!
  shouldResetPassword: Boolean!
  type: UserType
  updatedAt: DateTime!
}

input UserCreateInput {
  campaign: String
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  sendOTPEmail: Boolean
  type: String
}

enum UserType {
  CLOUDCITY
  EMPLOYEE
  LOCAL
}

input UserUpdateInput {
  avatarUrl: String
  campaign: String
  email: String
  firstName: String
  handle: String
  isEmailValidated: Boolean
  lastLogin: DateTime
  lastName: String
  password: String
  role: Role
  type: UserType
  updatedAt: DateTime
}

input UserUpdateManyMutationInput {
  isAdmin: BoolUpdateInput
  isDisabled: BoolUpdateInput
  lastLogin: DateTimeUpdateInput
  role: EnumRoleFieldUpdateOperationsInput
  shouldResetPassword: BoolUpdateInput
}

input UserWhereInput {
  AND: [UserWhereInput]
  NOT: [UserWhereInput]
  OR: [UserWhereInput]
  business: BusinessListRelationFilter
  campaign: StringFilter
  createdAt: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  isAdmin: BoolFilter
  isDisabled: BoolFilter
  isEmailValidated: BoolFilter
  lastLogin: DateTimeFilter
  lastName: StringFilter
  password: StringFilter
  role: EnumRoleFilter
  shouldResetPassword: BoolFilter
  type: StringFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}

type VerifyPayload {
  data: String
  error: Boolean
}

type Wallet {
  business: Business
  businessId: String!
  clientAddress: String
  createdAt: DateTime
  creditLimit: Decimal
  id: String!
  isActive: Boolean!
  multiSigAddress: String
}

type WalletBalance {
  availableCredit: Decimal
  balance: Decimal
  creditLimit: Decimal
}

input WalletWhereInput {
  AND: [WalletWhereInput]
  NOT: [WalletWhereInput]
  OR: [WalletWhereInput]
  businessId: StringFilter
  id: StringFilter
  multiSigAddress: StringFilter
}
